import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{o as n,c as e,e as i,a,f as t}from"./app-9efc0bdf.js";const o="/images/image-20240526225203437.png",l="/images/image-20240524180438360.png",p="/images/image-20240526222004063.png",r="/images/image-20240526222050730.png",c="/images/image-20240526222231534.png",d="/images/image-20240526222304393.png",m="/images/image-20240526234008438.png",u={},g=a("p",null,"Out of Memory（OOM）内存不足，从字面意思我们可以看出该异常的出现的原因是因内存不足导致的。",-1),v=a("p",null,"今天分析的此案例是近日我们生产环境出现的真实案例，出现问题的主要原因是随着业务量的增长，业务数据日益增长，在推送任务SQL查询的时候没有限制查询条数导致的，下面我们从0开始做一下复盘。",-1),b=t(`<p>通常由以下几个原因引起：</p><ul><li><p>内存泄漏：内存泄漏是指应用程序中的对象持有了对内存的引用，但无法被垃圾回收器释放。这些未被释放的对象会导致内存消耗增加，最终耗尽可用内存。</p></li><li><p>过度使用内存：应用程序在执行过程中分配了大量的内存对象，并且这些对象长时间存在于内存中，超出了JVM的可用内存限制，导致OOM错误。</p></li><li><p>大数据集处理：当处理大量数据时，如读取大型文件、处理数据库查询结果集等，如果不适当地管理数据，可能会导致内存占用过高，最终导致OOM问题。</p></li></ul><h2 id="_1、如何生成并导出hprof文件" tabindex="-1"><a class="header-anchor" href="#_1、如何生成并导出hprof文件" aria-hidden="true">#</a> 1、如何生成并导出hprof文件</h2><p>生成Dump文件，需要在JVM启动时添加参数：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 出现 OOME 时生成堆 dump:  </span>
<span class="token parameter variable">-XX:+HeapDumpOnOutOfMemoryError</span>

<span class="token comment"># 指定生成堆文件地址：</span>
<span class="token parameter variable">-XX:HeapDumpPath</span><span class="token operator">=</span>/xxx/DumpLogs/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2、分析hprof文件" tabindex="-1"><a class="header-anchor" href="#_2、分析hprof文件" aria-hidden="true">#</a> 2、分析hprof文件</h2><p>分析hprof文件我们这里采用的工具是 JProfiler，首先我们把获取到的hprof文件在JProfiler中打开</p><ol><li>点击单个快照选取我们获取到的hprof文件</li></ol><figure><img src="`+o+'" alt="打开快照" tabindex="0" loading="lazy"><figcaption>打开快照</figcaption></figure><ol start="2"><li>等到文件加载完成进入该页面（Classes），在顶部选择进入最大对象页面（Biggest Objects）</li></ol><figure><img src="'+l+'" alt="类页面" tabindex="0" loading="lazy"><figcaption>类页面</figcaption></figure><ol start="3"><li>对该页面的数据按照保留大小倒序排序，可以看到占用最大的对象</li></ol><figure><img src="'+p+'" alt="最大对象" tabindex="0" loading="lazy"><figcaption>最大对象</figcaption></figure><ol start="4"><li>右击选择使用选定对象（Use Slected Objects）</li></ol><figure><img src="'+r+'" alt="使用选定对象" tabindex="0" loading="lazy"><figcaption>使用选定对象</figcaption></figure><ol start="5"><li>选择传入引用（Incoming references）显示这个对象被谁引用</li></ol><figure><img src="'+c+'" alt="传入引用" tabindex="0" loading="lazy"><figcaption>传入引用</figcaption></figure><ol start="6"><li>进入引用页面（References）展开引用树，点击显示更多，即可在堆栈日志中查看到项目中内存泄漏的位置</li></ol><figure><img src="'+d+`" alt="引用页面" tabindex="0" loading="lazy"><figcaption>引用页面</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>java堆栈 of Thread-12
    at com.mysql.cj.protocol.a.TextResultsetReader.read(int, boolean, com.mysql.cj.protocol.a.NativePacketPayload, com.mysql.cj.protocol.ColumnDefinition, com.mysql.cj.protocol.ProtocolEntityFactory) (line: 87)
    at com.mysql.cj.protocol.a.TextResultsetReader.read(int, boolean, com.mysql.cj.protocol.Message, com.mysql.cj.protocol.ColumnDefinition, com.mysql.cj.protocol.ProtocolEntityFactory) (line: 48)
    .....
    at com.***.service.service.impl.***ServiceImpl.selectNoPush(java.time.LocalDateTime) (line: 290)
    at com.***.service.service.impl.***ServiceImpl.pushToGalaxy() (line: 248)
    at com.***.service.worker.handler.***ServiceImpl.execute(java.lang.String) (line: 32)
    at com.xxl.job.core.thread.JobThread.run() (line: 152)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3、定位问题" tabindex="-1"><a class="header-anchor" href="#_3、定位问题" aria-hidden="true">#</a> 3、定位问题</h2><p>上述已经找到项目中内存泄漏的位置，在项目中找到对应的位置</p><figure><img src="`+m+`" alt="代码定位" tabindex="0" loading="lazy"><figcaption>代码定位</figcaption></figure><p>定位到这行发现是一条SQL如下：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span>
	<span class="token operator">*</span> 
<span class="token keyword">FROM</span>
	push_table 
<span class="token keyword">WHERE</span>
	push_status <span class="token operator">=</span> <span class="token number">0</span>
	<span class="token operator">AND</span> updated_time <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token punctuation">[</span> CDATA <span class="token punctuation">[</span> <span class="token operator">&gt;=</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token comment">#{startTime,jdbcType=TIMESTAMP}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>乍一看该sql没什么问题，但是在生产中查询总数发现会因为数据突增查询出10W+的数据，一下导致内存不足，从而导致服务宕机</p><h2 id="_4、解决方案" tabindex="-1"><a class="header-anchor" href="#_4、解决方案" aria-hidden="true">#</a> 4、解决方案</h2><p>最终我们的解决方案是在查询sql时，时间设置范围 + 查询条数限制，来保证查询数据数量不会过大，导致OOM</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span>
	<span class="token operator">*</span> 
<span class="token keyword">FROM</span>
	push_table 
<span class="token keyword">WHERE</span>
	push_status <span class="token operator">=</span> <span class="token number">1</span>
	<span class="token operator">AND</span> updated_time <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token punctuation">[</span> CDATA <span class="token punctuation">[</span> <span class="token operator">&gt;=</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token comment">#{startTime,jdbcType=TIMESTAMP}</span>
	<span class="token operator">AND</span> updated_time <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token punctuation">[</span> CDATA <span class="token punctuation">[</span> <span class="token operator">&lt;=</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token comment">#{endTime,jdbcType=TIMESTAMP}</span>
	<span class="token keyword">LIMIT</span> <span class="token number">2000</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,29);function k(f,h){return n(),e("div",null,[g,v,i(" more "),b])}const x=s(u,[["render",k],["__file","OOM真实生产分析.html.vue"]]);export{x as default};
