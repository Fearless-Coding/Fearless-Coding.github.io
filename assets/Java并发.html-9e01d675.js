const e=JSON.parse('{"key":"v-3fbcb0ae","path":"/data/Java/Java%E5%B9%B6%E5%8F%91.html","title":"java并发","lang":"zh-CN","frontmatter":{"title":"java并发","index":true,"category":["使用指南"],"description":"并发路线 2.3.锁 如上一节所示，为一个无状态类添加一个状态域，只要这个状态域使用的是线程安全类，那么这个类仍是线程安全的。如果为一个无状态类添加两个状态域仍然不是线程安全的。线程安全性的定义需要在任何时候，多线程操作的任意重叠状态下都能保持约束条件。 在某些不幸的时间点UnsafeCachingFactorizer类可能会违反这个约束条件。虽然使用...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/data/Java/Java%E5%B9%B6%E5%8F%91.html"}],["meta",{"property":"og:title","content":"java并发"}],["meta",{"property":"og:description","content":"并发路线 2.3.锁 如上一节所示，为一个无状态类添加一个状态域，只要这个状态域使用的是线程安全类，那么这个类仍是线程安全的。如果为一个无状态类添加两个状态域仍然不是线程安全的。线程安全性的定义需要在任何时候，多线程操作的任意重叠状态下都能保持约束条件。 在某些不幸的时间点UnsafeCachingFactorizer类可能会违反这个约束条件。虽然使用..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-11T15:09:55.000Z"}],["meta",{"property":"article:author","content":"Fearless"}],["meta",{"property":"article:modified_time","content":"2023-12-11T15:09:55.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"java并发\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-12-11T15:09:55.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Fearless\\"}]}"]]},"headers":[{"level":3,"title":"2.3.锁","slug":"_2-3-锁","link":"#_2-3-锁","children":[]},{"level":3,"title":"2.4.使用锁确保对象状态一致性","slug":"_2-4-使用锁确保对象状态一致性","link":"#_2-4-使用锁确保对象状态一致性","children":[]},{"level":3,"title":"2.5.活跃性和性能","slug":"_2-5-活跃性和性能","link":"#_2-5-活跃性和性能","children":[]},{"level":2,"title":"3.1.内存可见性","slug":"_3-1-内存可见性","link":"#_3-1-内存可见性","children":[{"level":3,"title":"3.1.1.陈旧数据","slug":"_3-1-1-陈旧数据","link":"#_3-1-1-陈旧数据","children":[]},{"level":3,"title":"3.1.2.非原子性 64 位操作","slug":"_3-1-2-非原子性-64-位操作","link":"#_3-1-2-非原子性-64-位操作","children":[]},{"level":3,"title":"3.1.3.锁和可见性","slug":"_3-1-3-锁和可见性","link":"#_3-1-3-锁和可见性","children":[]},{"level":3,"title":"3.1.4. volatile域","slug":"_3-1-4-volatile域","link":"#_3-1-4-volatile域","children":[]}]},{"level":2,"title":"3.2.发表与逃逸","slug":"_3-2-发表与逃逸","link":"#_3-2-发表与逃逸","children":[{"level":3,"title":"3.2.1.安全构造实践","slug":"_3-2-1-安全构造实践","link":"#_3-2-1-安全构造实践","children":[]}]},{"level":2,"title":"JDK.Future.get() ：多线程里获取线程执行结果，异步阻塞问题","slug":"jdk-future-get-多线程里获取线程执行结果-异步阻塞问题","link":"#jdk-future-get-多线程里获取线程执行结果-异步阻塞问题","children":[]},{"level":2,"title":"Guava Future 异步非阻塞执行","slug":"guava-future-异步非阻塞执行","link":"#guava-future-异步非阻塞执行","children":[]},{"level":2,"title":"ThreadPoolExecutor","slug":"threadpoolexecutor","link":"#threadpoolexecutor","children":[]}],"git":{"createdTime":1702307395000,"updatedTime":1702307395000,"contributors":[{"name":"pzy","email":"66700800@qq.com","commits":1}]},"readingTime":{"minutes":32.12,"words":9636},"filePathRelative":"data/Java/Java并发.md","localizedDate":"2023年12月11日","autoDesc":true}');export{e as data};
