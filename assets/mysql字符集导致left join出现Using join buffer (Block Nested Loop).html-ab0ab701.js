const e=JSON.parse('{"key":"v-7223408b","path":"/data/%E7%9C%9F%E5%AE%9E%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/mysql%E5%AD%97%E7%AC%A6%E9%9B%86%E5%AF%BC%E8%87%B4left%20join%E5%87%BA%E7%8E%B0Using%20join%20buffer%20(Block%20Nested%20Loop).html","title":"OOM真实案例分析及解决方案","lang":"zh-CN","frontmatter":{"title":"OOM真实案例分析及解决方案","category":["案例分析"],"tag":["OOM","JProfiler","hprof"],"description":"mysql字符集导致left join出现Using join buffer (Block Nested Loop) 后台管理分页查询时，发现请求接口超时 问题追踪 查看日志，发现日志中打印的分页查询的数据，发现异常，查看响应时间41秒，一个分页查询请求41秒大概率是因为慢SQL，接着我们分析sql发现查询确实很慢 问题分析 确认了是SQL的原因，通过explain分析，发现left join关联的表竟然全是全表扫描，此时我们确认表中是否有关联字段索引，发现索引也有，那为什么有索引却不走索引呢，查看explain中 extra 列，发现一个从未见过的信息 **Using where； Using join buffer (Block Nested Loop) **，官方文档解释如下，使用连接缓冲区(块嵌套循环)，相当于我们代码中的两层for循环，随着数据量的增加查询效率也会成倍增加。","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/data/%E7%9C%9F%E5%AE%9E%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/mysql%E5%AD%97%E7%AC%A6%E9%9B%86%E5%AF%BC%E8%87%B4left%20join%E5%87%BA%E7%8E%B0Using%20join%20buffer%20(Block%20Nested%20Loop).html"}],["meta",{"property":"og:title","content":"OOM真实案例分析及解决方案"}],["meta",{"property":"og:description","content":"mysql字符集导致left join出现Using join buffer (Block Nested Loop) 后台管理分页查询时，发现请求接口超时 问题追踪 查看日志，发现日志中打印的分页查询的数据，发现异常，查看响应时间41秒，一个分页查询请求41秒大概率是因为慢SQL，接着我们分析sql发现查询确实很慢 问题分析 确认了是SQL的原因，通过explain分析，发现left join关联的表竟然全是全表扫描，此时我们确认表中是否有关联字段索引，发现索引也有，那为什么有索引却不走索引呢，查看explain中 extra 列，发现一个从未见过的信息 **Using where； Using join buffer (Block Nested Loop) **，官方文档解释如下，使用连接缓冲区(块嵌套循环)，相当于我们代码中的两层for循环，随着数据量的增加查询效率也会成倍增加。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-18T09:23:32.000Z"}],["meta",{"property":"article:author","content":"Fearless"}],["meta",{"property":"article:tag","content":"OOM"}],["meta",{"property":"article:tag","content":"JProfiler"}],["meta",{"property":"article:tag","content":"hprof"}],["meta",{"property":"article:modified_time","content":"2024-11-18T09:23:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"OOM真实案例分析及解决方案\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-18T09:23:32.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Fearless\\"}]}"]]},"headers":[{"level":2,"title":"问题追踪","slug":"问题追踪","link":"#问题追踪","children":[]},{"level":2,"title":"问题分析","slug":"问题分析","link":"#问题分析","children":[]},{"level":2,"title":"解决方案","slug":"解决方案","link":"#解决方案","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1731921812000,"updatedTime":1731921812000,"contributors":[{"name":"pzy","email":"66700800@qq.com","commits":1}]},"readingTime":{"minutes":2.83,"words":849},"filePathRelative":"data/真实案例分析/mysql字符集导致left join出现Using join buffer (Block Nested Loop).md","localizedDate":"2024年11月18日","excerpt":"<h1> mysql字符集导致left join出现Using join buffer (Block Nested Loop)</h1>\\n<p>后台管理分页查询时，发现请求接口超时</p>\\n<h2> 问题追踪</h2>\\n<p>查看日志，发现日志中打印的分页查询的数据，发现异常，查看响应时间41秒，一个分页查询请求41秒大概率是因为慢SQL，接着我们分析sql发现查询确实很慢</p>\\n<h2> 问题分析</h2>\\n<p>确认了是SQL的原因，通过explain分析，发现left join关联的表竟然全是全表扫描，此时我们确认表中是否有关联字段索引，发现索引也有，那为什么有索引却不走索引呢，查看explain中 extra 列，发现一个从未见过的信息 **Using where； Using join buffer (Block Nested Loop) **，官方文档解释如下，使用连接缓冲区(块嵌套循环)，相当于我们代码中的两层for循环，随着数据量的增加查询效率也会成倍增加。</p>","autoDesc":true}');export{e as data};
