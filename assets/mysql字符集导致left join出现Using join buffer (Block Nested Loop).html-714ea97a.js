import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as a,c,a as e,d as o,b as t,f as s}from"./app-c7a93f02.js";const l={},d=s('<h1 id="mysql字符集导致left-join出现using-join-buffer-block-nested-loop" tabindex="-1"><a class="header-anchor" href="#mysql字符集导致left-join出现using-join-buffer-block-nested-loop" aria-hidden="true">#</a> mysql字符集导致left join出现Using join buffer (Block Nested Loop)</h1><p>后台管理分页查询时，发现请求接口超时</p><h2 id="问题追踪" tabindex="-1"><a class="header-anchor" href="#问题追踪" aria-hidden="true">#</a> 问题追踪</h2><p>查看日志，发现日志中打印的分页查询的数据，发现异常，查看响应时间41秒，一个分页查询请求41秒大概率是因为慢SQL，接着我们分析sql发现查询确实很慢</p><h2 id="问题分析" tabindex="-1"><a class="header-anchor" href="#问题分析" aria-hidden="true">#</a> 问题分析</h2><p>确认了是SQL的原因，通过explain分析，发现left join关联的表竟然全是全表扫描，此时我们确认表中是否有关联字段索引，发现索引也有，那为什么有索引却不走索引呢，查看explain中 extra 列，发现一个从未见过的信息 **Using where； Using join buffer (Block Nested Loop) **，官方文档解释如下，使用连接缓冲区(块嵌套循环)，相当于我们代码中的两层for循环，随着数据量的增加查询效率也会成倍增加。</p>',6),h=e("p",null,[e("code",null,"Using join buffer (Block Nested Loop)"),o(", "),e("code",null,"Using join buffer (Batched Key Access)"),o(", "),e("code",null,"Using join buffer (hash join)"),o(" (JSON property: "),e("code",null,"using_join_buffer"),o(")")],-1),f=e("code",null,"(Block Nested Loop)",-1),_=e("code",null,"(Batched Key Access)",-1),u=e("code",null,"(hash join)",-1),p={href:"https://dev.mysql.com/doc/refman/8.4/en/explain.html",target:"_blank",rel:"noopener noreferrer"},b=e("code",null,"EXPLAIN",-1),m=e("code",null,"Using join buffer",-1),j=s("<p>In JSON-formatted output, the value of <code>using_join_buffer</code> is always one of <code>Block Nested Loop</code>, <code>Batched Key Access</code>, or <code>hash join</code>.</p><p>使用连接缓冲区(块嵌套循环)，使用连接缓冲区(批处理键访问)，使用连接缓冲区(哈希连接)(JSON属性:using_join_buffer)</p><p>将早期连接中的表分段读入连接缓冲区，然后从缓冲区中使用它们的行来执行与当前表的连接。(块嵌套循环)表示使用块嵌套循环算法，(批处理键访问)表示使用批处理键访问算法，(散列连接)表示使用散列连接。也就是说，将对EXPLAIN输出的前一行表中的键进行缓冲，并从出现Using join buffer的行所表示的表中批量获取匹配的行。</p><p>在json格式的输出中，using_join_buffer的值始终是块嵌套循环、批处理键访问或散列连接中的一个。</p>",4),g=e("p",null,"此时还没看出问题的原因，这时度娘找到一个问题相似的回答，发现竟是字符集不一致导致的问题",-1),k={href:"https://www.cnblogs.com/i-tao/p/15701072.html",target:"_blank",rel:"noopener noreferrer"},x=e("h2",{id:"解决方案",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#解决方案","aria-hidden":"true"},"#"),o(" 解决方案")],-1),y=e("p",null,"将 left join 中的关联字段字符集设置一致，查看 explain key 走了主键索引和普通索引，type 也达到了eq_type 级别，此时问题已解决",-1),N=e("h2",{id:"总结",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#总结","aria-hidden":"true"},"#"),o(" 总结")],-1),B=e("p",null,"在我们开发过程中我们很少会关注字符集的设置，新项目中为了支持emoji表情都会设置为utfmb4，但是可以有些比较老的项目可能设置字符集为utf-8，就会导致这个的出现，在开发过程中建表时重点关注新表和历史表中的字段字符集",-1),q={href:"https://mp.weixin.qq.com/s?__biz=MzkwODI2ODc3OQ==&mid=2247484237&idx=1&sn=23a63170018b3569d696e52e8222708b&chksm=c0cdc6c9f7ba4fdf5638534da76c117d73d57d98a949b0fae81ce113a38985f3923f9c979540&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"},L={href:"https://blog.csdn.net/qq_32078397/article/details/117766575",target:"_blank",rel:"noopener noreferrer"};function w(U,A){const n=i("ExternalLinkIcon");return a(),c("div",null,[d,e("blockquote",null,[h,e("p",null,[o("Tables from earlier joins are read in portions into the join buffer, and then their rows are used from the buffer to perform the join with the current table. "),f,o(" indicates use of the Block Nested-Loop algorithm, "),_,o(" indicates use of the Batched Key Access algorithm, and "),u,o(" indicates use of a hash join. That is, the keys from the table on the preceding line of the "),e("a",p,[b,t(n)]),o(" output are buffered, and the matching rows are fetched in batches from the table represented by the line in which "),m,o(" appears.")]),j]),g,e("p",null,[e("a",k,[o("mysql因为字符集导致left join出现Using join buffer (Block Nested Loop)"),t(n)])]),x,y,N,B,e("blockquote",null,[e("p",null,[e("a",q,[o("了解字符集"),t(n)])]),e("p",null,[e("a",L,[o("explain之extra"),t(n)])])])])}const S=r(l,[["render",w],["__file","mysql字符集导致left join出现Using join buffer (Block Nested Loop).html.vue"]]);export{S as default};
